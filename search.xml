<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL学习</title>
    <url>/2022/02/13/MySQL/</url>
    <content><![CDATA[<p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标"></p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/02/12/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Git学习</title>
    <url>/2022/02/13/Git/index/</url>
    <content><![CDATA[<ol>
<li>第一项：<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项：<ul>
<li>第二项嵌套的第一个元素</li>
<li>第二项嵌套的第二个元素</li>
</ul>
</li>
<li>Git学习</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Python基础</title>
    <url>/2022/02/15/categories/index/</url>
    <content><![CDATA[<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval() 去除最外层引号，也可以在此函数内部进行 数字运算</span><br><span class="line">complex() 用来生成复数</span><br><span class="line">abs() 绝对值计算</span><br><span class="line">divmod() 同时计算两个数字的整数商和余数</span><br><span class="line">pow() 计算幂，第一个参数为底数，第二个参数为指数</span><br><span class="line">round() 进行四舍五入</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str.format() 字符串格式化</span><br><span class="line">str.count() 计算算该字符出现的次数</span><br><span class="line">str.index() 查询字符第一次出现的索引</span><br><span class="line">str.capitalize() 首字母大写</span><br><span class="line">str.title() 每个单词的首字母大写</span><br><span class="line">str.lower() 将字符串中所有的大写转换为小写</span><br><span class="line">str.upper() 将string中小写字母转换为大写</span><br><span class="line">str.swapcase() 将string字母大小写翻转</span><br><span class="line">str.split() 分割字符串，默认空格分割</span><br><span class="line">str.replace(old,new) 将old字符串替换为new</span><br><span class="line">str.center(width,fillchar) 第一个参数为返回指定的字符长度。第二个参数为使用指定字符填充</span><br><span class="line">str.strip(chars) 删除str字符串中指定的参数</span><br><span class="line">str.join() 使用指定字符串拼接</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    正常要处理的代码块</span><br><span class="line">except：</span><br><span class="line">    出现异常执行的代码块</span><br><span class="line">else:</span><br><span class="line">    没有异常执行的代码块</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意：元组一旦创建就不能再改动，当元组内仅有一个元素时，需在元素后加一个逗号&quot;,&quot;</span><br><span class="line">元组的索引：元组名[index]</span><br></pre></td></tr></table></figure>

<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><table>
<thead>
<tr>
<th>增加</th>
</tr>
</thead>
<tbody><tr>
<td>[].insert(索引，元素)    在指定位置插入元素</td>
</tr>
<tr>
<td>[].append(元素)   在末尾追加元素</td>
</tr>
<tr>
<td>[].extend(列表2)    将列表2追加到原列表后</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>删除</th>
</tr>
</thead>
<tbody><tr>
<td>[].remore(元素)       删除第一个出现的指定元素</td>
</tr>
<tr>
<td>[].pop(index)           默认删除末尾元素，由index指定删除索引元素</td>
</tr>
<tr>
<td>[].clear()                    清空列表</td>
</tr>
<tr>
<td>del 列表[索引]           删除指定索引元素</td>
</tr>
<tr>
<td>列表[索引] &#x3D; 元素      修改指定索引的元素</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>R语言基础</title>
    <url>/2022/03/20/R/index/</url>
    <content><![CDATA[<h2 id="R语言基础"><a href="#R语言基础" class="headerlink" title="R语言基础"></a>R语言基础</h2><h4 id="基本命令："><a href="#基本命令：" class="headerlink" title="基本命令："></a>基本命令：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls() list当前工作区内存中的变量</span><br><span class="line"></span><br><span class="line">rm(args)  移除内存变量Remove Object</span><br><span class="line"></span><br><span class="line">history()  查看历史命令清单</span><br><span class="line"></span><br><span class="line">help(“函数”)  打开函数帮助文档</span><br><span class="line"></span><br><span class="line">names(变量)  返回数据集中名字属性</span><br><span class="line"></span><br><span class="line">mode(变量)/class(变量)  返回基本数据类型</span><br><span class="line"></span><br><span class="line">is(变量)  返回变量的基本数据类型和高级数据类型</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="变量命令规则："><a href="#变量命令规则：" class="headerlink" title="变量命令规则："></a>变量命令规则：</h4><p>1.字母、数字或者下划线组成；</p>
<p>2.变量名称以字母开头，或者点后面不带数字。</p>
<h4 id="运算符："><a href="#运算符：" class="headerlink" title="运算符："></a>运算符：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.算数运算符：+ 、-、*、/ 、%%(求余)、%/%(求商)、%in%(判断除数和被除数是否相等)；</span><br><span class="line"></span><br><span class="line">2.关系运算符：&gt;、&lt;、==、&gt;=、&lt;=、！=</span><br><span class="line"></span><br><span class="line">3.赋值运算符：&lt;-、=</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="基本数据类型："><a href="#基本数据类型：" class="headerlink" title="基本数据类型："></a>基本数据类型：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a)     数字   numeric eg:1、-2、0.7</span><br><span class="line">b)     字符   character  eg:”hello”</span><br><span class="line">c)     逻辑型 logical      eg:TRUE、FALSE</span><br><span class="line">d)     日期时间型  data/datatime</span><br><span class="line">e)     空值    NA</span><br></pre></td></tr></table></figure>

<h4 id="高级数据类型—向量vector："><a href="#高级数据类型—向量vector：" class="headerlink" title="高级数据类型—向量vector："></a>高级数据类型—向量vector：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. x&lt;-c(1,2,3,6.7)</span><br><span class="line">2.  z&lt;-1:100  s&lt;-seq(1,100) 生成元素从1到100的向量</span><br><span class="line">3.  s&lt;-req(1:100,2)   生成两次元素是1:到100的向量</span><br><span class="line">4. a&lt;-req(x,10)  生成10次向量x</span><br><span class="line">5. b&lt;-seq(-10,10,0.5)  生成元素从-10到10的向量，增加梯度为0.5</span><br></pre></td></tr></table></figure>

<h4 id="向量访问："><a href="#向量访问：" class="headerlink" title="向量访问："></a>向量访问：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.  x[1]  返回向量x的第一个元素</span><br><span class="line">2.  x[-1]  移除向量x的第一个元素外的向量</span><br><span class="line">3.  y[2:3]   向量第2到第3个原始组成的向量(包前包后)</span><br><span class="line">4. x[x&gt;2]   向量x中，元素大于2组成的新的向量</span><br><span class="line">5. x[c(2,3,7)]  输出向量第2、3、7位置的元素组成的新向量</span><br><span class="line">6. index &lt;- which(x==9)   获取数据对应的索引值</span><br></pre></td></tr></table></figure>

<h4 id="向量运算："><a href="#向量运算：" class="headerlink" title="向量运算："></a>向量运算：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 相同程度：</span><br><span class="line">       a&lt;-c(3,8,4,5,0,11)</span><br><span class="line">       b&lt;-c(4,11,0,8,12)</span><br><span class="line">       c&lt;-a+b</span><br><span class="line">       [1] 7 19 4 13 1 13</span><br><span class="line">2. 不同长度(长度必须是倍数关系)</span><br><span class="line">       a&lt;-c(3,8,4,5,0,11)</span><br><span class="line">       b&lt;-c(4,11)</span><br><span class="line">       c=a+b</span><br><span class="line">       [1] 7 19 8 16 4 22</span><br></pre></td></tr></table></figure>

<h4 id="向量排序"><a href="#向量排序" class="headerlink" title="向量排序:"></a>向量排序:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v&lt;-c(3,8,4,5,0,11)</span><br><span class="line">sort(v)</span><br><span class="line">[1] 0 3 4 5 8 11</span><br></pre></td></tr></table></figure>

<h4 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算:"></a>矩阵运算:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义：matrix(data,nrow,ncol,byrow,dimnames)</span><br><span class="line">Byrow:逻辑线索，如果为TRUE，则输入向量元素按行排序，否则按列排序。</span><br><span class="line">例子：</span><br><span class="line">a&lt;-matrix(2:7,2,3,TRUE)</span><br></pre></td></tr></table></figure>

<h4 id="矩阵访问"><a href="#矩阵访问" class="headerlink" title="矩阵访问:"></a>矩阵访问:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.a[1,1:3]  取第一行向量</span><br><span class="line">2.a[-1]    除去一行后的矩阵</span><br><span class="line">3.a[1:2,1:2]  部分矩阵</span><br></pre></td></tr></table></figure>

<h4 id="数组-array"><a href="#数组-array" class="headerlink" title="数组(array):"></a>数组(array):</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建三维数组：xx&lt;-array(1:24,c(3,4,2))</span><br><span class="line">2.创建四维数组：yy&lt;-array(1:36,c(2,3,3,2))</span><br></pre></td></tr></table></figure>

<h4 id="维度转换："><a href="#维度转换：" class="headerlink" title="维度转换："></a>维度转换：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x&lt;-1:36</span><br><span class="line">dim(x)&lt;-c(6,2,3)  转换为6行、2列、3页的三维数组</span><br><span class="line">dim(x)&lt;-c(9,4)    转换为9X4的矩阵</span><br><span class="line">dim(x)&lt;-36       转化为长度为36的向量</span><br></pre></td></tr></table></figure>

<h4 id="列表："><a href="#列表：" class="headerlink" title="列表："></a>列表：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建列表：list(name1=value1,name2-value2,…)</span><br><span class="line">2.访问列表：list$name1</span><br></pre></td></tr></table></figure>







<h4 id="基础实例："><a href="#基础实例：" class="headerlink" title="基础实例："></a>基础实例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#把x赋值为一个从1到20的整型数向量  </span><br><span class="line">x = 1:20</span><br><span class="line">print(x)</span><br><span class="line">#在x上添加均值为0、标准差为2的正态分布噪声，然后赋给y  </span><br><span class="line">y = x + rnorm(20,0,2)</span><br><span class="line">print(y)</span><br><span class="line">#完成y~x的线性回归，结果保存到变量fit  </span><br><span class="line">fit = lm(y~x)</span><br><span class="line">#概要显示线性回归的结果 </span><br><span class="line">summary(fit)</span><br><span class="line">#画出y~x的散点图。</span><br><span class="line">plot(x,y)</span><br><span class="line"></span><br><span class="line">#产生5000个正态分布随机数并取整   </span><br><span class="line">n = floor(rnorm(5000,100,10))</span><br><span class="line">print(n)</span><br><span class="line">#统计n中所有整数出现的次数  </span><br><span class="line">t = table(n)</span><br><span class="line">print(t)</span><br><span class="line">#画出柱状图</span><br><span class="line">barplot(t)</span><br></pre></td></tr></table></figure>

<h4 id="使用帮助实例"><a href="#使用帮助实例" class="headerlink" title="使用帮助实例:"></a>使用帮助实例:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?format</span><br><span class="line">help(&quot;sprintf&quot;)</span><br><span class="line">help.start()</span><br></pre></td></tr></table></figure>

<h4 id="使用source函数执行R脚本："><a href="#使用source函数执行R脚本：" class="headerlink" title="使用source函数执行R脚本："></a>使用source函数执行R脚本：</h4><p>1.编写脚本文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = runif(100,0,2)</span><br><span class="line">hist(a)</span><br><span class="line">mean(a)</span><br><span class="line">range(a)</span><br><span class="line">max(a)</span><br><span class="line">min(a)</span><br></pre></td></tr></table></figure>

<p>2.编写运行脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#路径中间使用“//”</span><br><span class="line">source(&quot;C:\\Users\\86185\\Desktop\\R\\源代码\\text.R&quot;,print.eval=TRUE)</span><br></pre></td></tr></table></figure>

<p>3.在运行脚本中运行</p>
<h4 id="创建矩阵使其完成横-纵-向拼接"><a href="#创建矩阵使其完成横-纵-向拼接" class="headerlink" title="创建矩阵使其完成横(纵)向拼接:"></a>创建矩阵使其完成横(纵)向拼接:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#定义第一个三行四列的矩阵a</span><br><span class="line">a &lt;- matrix(1:12,nrow = 3)</span><br><span class="line">print(a)</span><br><span class="line">#定义第二个三行四列的矩阵b</span><br><span class="line">b &lt;- matrix(12:23,nrow = 3)</span><br><span class="line">print(b)</span><br><span class="line"># a b 按行合并</span><br><span class="line">c &lt;- rbind(a,b)</span><br><span class="line">print(c)</span><br><span class="line">#a b 按列合并</span><br><span class="line">d &lt;- cbind(a,b)</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure>

<h4 id="创建三维-四维-数组"><a href="#创建三维-四维-数组" class="headerlink" title="创建三维(四维)数组:"></a>创建三维(四维)数组:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建三维数组</span><br><span class="line">a1 &lt;- array(1:24,c(3,4,2))</span><br><span class="line">a1</span><br><span class="line">#创建四维数组</span><br><span class="line">b1 &lt;- array(1:36,c(2,3,3,2))</span><br><span class="line">b1</span><br><span class="line">#三维数组可视为以二维数组为数据元素的向量。</span><br><span class="line">#四维数组可视为以三维数组为数据元素的向量……</span><br><span class="line">#三维数组中的每个元素都属于三个向量。</span><br><span class="line">#四维数组中的每个元素都属于四个向量……</span><br><span class="line"></span><br><span class="line">#数组的顺序存储方式:</span><br><span class="line">#由于计算机内存是一维的，多维数组的元素应排成线性序列后存人存储器。</span><br><span class="line">#数组一般不做插入和删除操作，即结构中元素个数和元素间关系不变化。</span><br><span class="line">#一般采用顺序存储方法表示数组。</span><br></pre></td></tr></table></figure>

<h4 id="列表创建及访问："><a href="#列表创建及访问：" class="headerlink" title="列表创建及访问："></a>列表创建及访问：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#获取外部矩阵数据</span><br><span class="line">source(&quot;C:\\Users\\86185\\Desktop\\R\\源代码\\juzhen.R&quot;,print.eval=TRUE)</span><br><span class="line">#获取外部数组数据</span><br><span class="line">source(&quot;C:\\Users\\86185\\Desktop\\R\\源代码\\shuzu.R&quot;,print.eval=TRUE)</span><br><span class="line">#定义列表</span><br><span class="line">lists = list(n=a,b,a1,b1)</span><br><span class="line">#可以通过下标索引访问列表元素 下标从1开始</span><br><span class="line">lists[2]</span><br></pre></td></tr></table></figure>

<h4 id="数据框创建："><a href="#数据框创建：" class="headerlink" title="数据框创建："></a>数据框创建：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建数据框</span><br><span class="line">df &lt;- data.frame(</span><br><span class="line">  姓名=c(&quot;张三&quot;,&quot;小吕&quot;,&quot;小雪&quot;),</span><br><span class="line">  性别=c(&quot;女&quot;,&quot;男&quot;,&quot;女&quot;),</span><br><span class="line">  年龄=c(20,21,22),</span><br><span class="line">  #设置每一行的名称</span><br><span class="line">  row.names=c(&quot;第一行&quot;,&quot;第二行&quot;,&quot;第三行&quot;)</span><br><span class="line">)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>

<h4 id="R实现汉诺塔递归"><a href="#R实现汉诺塔递归" class="headerlink" title="R实现汉诺塔递归:"></a>R实现汉诺塔递归:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">han &lt;- function(n,from=&#x27;T1&#x27;,to=&#x27;T3&#x27;,by=&quot;T2&quot;) &#123;</span><br><span class="line">  if(n==1)cat(&quot;move&quot;,n,&quot;from&quot;,from,&quot;to&quot;,to,&quot;\n&quot;)</span><br><span class="line">  if(n&gt;1)&#123;</span><br><span class="line">    han(n-1,from,by,to)</span><br><span class="line">    cat(&quot;move&quot;,n,&quot;from&quot;,from,&quot;to&quot;,to,&quot;\n&quot;)</span><br><span class="line">    han(n-1,by,to,from)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">han(5)</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/03/20/basicas/index/</url>
    <content><![CDATA[<h4 id="第一章复习点"><a href="#第一章复习点" class="headerlink" title="第一章复习点"></a>第一章复习点</h4><h5 id="考点一（填空）："><a href="#考点一（填空）：" class="headerlink" title="考点一（填空）："></a>考点一（填空）：</h5><p>计算机的分类：1.电子模拟计算机   2.电子数字计算机</p>
<table>
<thead>
<tr>
<th>比较内容</th>
<th>电子数字计算机</th>
<th>电子模拟计算机</th>
</tr>
</thead>
<tbody><tr>
<td>数据表示方式</td>
<td>数字0和1</td>
<td>电压</td>
</tr>
<tr>
<td>计算方式</td>
<td>数字计算</td>
<td>电压</td>
</tr>
<tr>
<td>控制方式</td>
<td>程序控制</td>
<td>盘上连接</td>
</tr>
<tr>
<td>精度</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>数据存储量</td>
<td>大</td>
<td>小</td>
</tr>
<tr>
<td>逻辑判断能力</td>
<td>强</td>
<td>无</td>
</tr>
</tbody></table>
<h5 id="考点二（选择）："><a href="#考点二（选择）：" class="headerlink" title="考点二（选择）："></a>考点二（选择）：</h5><p>计算机的发展简史：</p>
<table>
<thead>
<tr>
<th>计算机的五代变化</th>
<th>半导体存储器的发展</th>
</tr>
</thead>
<tbody><tr>
<td>第一代为1946~1957年    电子计算机</td>
<td>1970年，仙童半导体公司生产出第一个较大容量半导体存储器</td>
</tr>
<tr>
<td>第二代为1958~1964 年   晶体管计算机</td>
<td>1974年，每位半导体存储器的价格低于磁芯</td>
</tr>
</tbody></table>
<h5 id="考点三（判断）："><a href="#考点三（判断）：" class="headerlink" title="考点三（判断）："></a>考点三（判断）：</h5><table>
<thead>
<tr>
<th>计算机的性能指标</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>吞吐量</td>
<td>计算机在某一时间间隔内可以处理的信息量</td>
</tr>
<tr>
<td>响应时间</td>
<td>从输入有效到系统产生响应之间的时间度量</td>
</tr>
<tr>
<td>利用率</td>
<td>时间间隔一定时，系统被实际使用的时间所占的比率</td>
</tr>
<tr>
<td>处理机字长</td>
<td>处理机运算器一次能够完成二进制数运算的位数</td>
</tr>
<tr>
<td>总线宽度</td>
<td>CPU内部运算器与存储器进行互连的内部总线二进制位数</td>
</tr>
<tr>
<td>存储器容量</td>
<td>所有存储单元的总数目</td>
</tr>
<tr>
<td>存储器宽带</td>
<td>单位时间内从存储器读出的二进制数信息量</td>
</tr>
<tr>
<td>主频&#x2F;时钟周期</td>
<td>主时钟的频率(f)叫做CPU的主频，主频的倒数称为CPU的时钟周期(T),T&#x3D;1&#x2F;f</td>
</tr>
<tr>
<td>CPU执行时间</td>
<td>执行一段程序所占用CPU的时间：CPU的时钟周期 * CPU的时钟周期</td>
</tr>
<tr>
<td>CPI</td>
<td>执行一条指令所需的平均时钟周期数：CPI&#x3D;CPU的时钟周期&#x2F;程序包含的指令条数</td>
</tr>
<tr>
<td>MIPS</td>
<td>MIPS&#x3D;指令数&#x2F;(程序执行时间*10^6)</td>
</tr>
<tr>
<td>FLOPS</td>
<td>FLOPS&#x3D;程序中的浮点操作次数&#x2F;程序执行时间</td>
</tr>
</tbody></table>
<h5 id="考点四（选择）："><a href="#考点四（选择）：" class="headerlink" title="考点四（选择）："></a>考点四（选择）：</h5><table>
<thead>
<tr>
<th>运算器</th>
<th>相当于键盘运算功能的部件</th>
</tr>
</thead>
<tbody><tr>
<td>存储器</td>
<td>具有记忆功能的部件</td>
</tr>
<tr>
<td>输入&#x2F;输出设备</td>
<td>将信息传送到计算机或将运算结果显示出来的设备</td>
</tr>
<tr>
<td>控制器</td>
<td>控制整个计算流程</td>
</tr>
</tbody></table>
<h5 id="考点五（判断）："><a href="#考点五（判断）：" class="headerlink" title="考点五（判断）："></a>考点五（判断）：</h5><table>
<thead>
<tr>
<th>计算机软件分类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>系统程序</td>
<td>各种服务型程序、语言程序、操作系统、数据库管理系统</td>
</tr>
<tr>
<td>应用程序</td>
<td>工程设计程序、数据处理程序、科学计算程序、数据控制程序等</td>
</tr>
</tbody></table>
<h4 id="第二章复习点："><a href="#第二章复习点：" class="headerlink" title="第二章复习点："></a>第二章复习点：</h4><h5 id="考点一（多选）"><a href="#考点一（多选）" class="headerlink" title="考点一（多选）:"></a>考点一（多选）:</h5><table>
<thead>
<tr>
<th>计算机数的表示方式</th>
</tr>
</thead>
<tbody><tr>
<td>1.数的类型（小数、整数、实数和复数）</td>
</tr>
<tr>
<td>2.数值的范围</td>
</tr>
<tr>
<td>3.数值精确度</td>
</tr>
<tr>
<td>4.数据存储和处理所需的硬件代价</td>
</tr>
</tbody></table>
<h5 id="考点二（计算题）"><a href="#考点二（计算题）" class="headerlink" title="考点二（计算题）:"></a>考点二（计算题）:</h5><p>当符号位为正时补位运算‘+’为0，‘-’为1</p>
<p>求 [-x]补时数字从右向左遇到第一个 1 之后左侧数字全部取反，包括符号位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = +1011 , y = -0101 ,求 x+y</span><br><span class="line">    [x]补        01011</span><br><span class="line">  + [y]补        10101</span><br><span class="line"> ————————————————————————</span><br><span class="line">   [x+y]补    _1_00110</span><br><span class="line">   </span><br><span class="line">所以 x+y = +0110</span><br></pre></td></tr></table></figure>

<p>求 [-x]补时数字从右向左遇到第一个 1 之后左侧数字全部取反，包括符号位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = +1011 , y = +0111 ,求 x-y</span><br><span class="line">解：[x]补=01011  [y]补=00111  [-y]补=11010</span><br><span class="line">    [x]补        01101</span><br><span class="line">  + [-y]补       11010</span><br><span class="line"> ————————————————————————</span><br><span class="line">   [x-y]补    _1_00111</span><br><span class="line">   </span><br><span class="line">所以 x+y = +0111</span><br></pre></td></tr></table></figure>

<h5 id="考点三（填空）"><a href="#考点三（填空）" class="headerlink" title="考点三（填空）:"></a>考点三（填空）:</h5><p>计算机中的逻辑运算，主要是指<strong>逻辑非</strong>、<strong>逻辑 加</strong>、<strong>逻辑乘</strong>、<strong>逻辑异</strong>等四种基本运算 </p>
<h5 id="考点四："><a href="#考点四：" class="headerlink" title="考点四："></a>考点四：</h5><p>课本练习题（p61）</p>
<h4 id="第三章复习点："><a href="#第三章复习点：" class="headerlink" title="第三章复习点："></a>第三章复习点：</h4><h5 id="考点一"><a href="#考点一" class="headerlink" title="考点一:"></a>考点一:</h5><table>
<thead>
<tr>
<th>RAM信息存储方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>静态RAM（SRAM）</td>
<td>SRAM是通过半导体管的‘导通’或‘截止’来记忆的，只要不漏电，储存信息就不会丢失</td>
</tr>
<tr>
<td>动态RAM（DRAM）</td>
<td>需要周期性的刷新</td>
</tr>
</tbody></table>
<h5 id="考点二："><a href="#考点二：" class="headerlink" title="考点二："></a>考点二：</h5><table>
<thead>
<tr>
<th>存储器的编址</th>
</tr>
</thead>
<tbody><tr>
<td>字存储单元：存放一个机器字的存储单元</td>
</tr>
<tr>
<td>字地址：相应的单元地址</td>
</tr>
<tr>
<td>字节存储单元：存放一字节的单元</td>
</tr>
<tr>
<td>字节地址：相应的地址</td>
</tr>
</tbody></table>
<h5 id="考点三："><a href="#考点三：" class="headerlink" title="考点三："></a>考点三：</h5><table>
<thead>
<tr>
<th>DRAM的刷新操作</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>集中式刷新策略</td>
<td>集中一段时间对DRAM的所有行进行刷新</td>
</tr>
<tr>
<td>分散式刷新策略</td>
<td>每一行的刷新操作被均匀地分配到刷新周期时间内</td>
</tr>
</tbody></table>
<h5 id="考点四：-1"><a href="#考点四：-1" class="headerlink" title="考点四："></a>考点四：</h5><p>课本练习题（p118）</p>
<h4 id="第四章复习点："><a href="#第四章复习点：" class="headerlink" title="第四章复习点："></a>第四章复习点：</h4><p>例题：某机主存容量4M*16位，且存储字长等于指令字长，若该机指令系统可完成108种操作，操作码位数固定，且具有直接、间接、变址、基址、相对、立即等六种寻址方式，试回答：</p>
<table>
<thead>
<tr>
<th>例题</th>
<th>解答</th>
</tr>
</thead>
<tbody><tr>
<td>画出一地址指令格式并指出名字段的作用</td>
<td>地址指令格式：<img src="https://siamesecats.github.io/img/1.png" alt="img"></td>
</tr>
<tr>
<td>该指令直接寻址的最大范围</td>
<td>直接寻址的最大范围：2^6</td>
</tr>
<tr>
<td>一次间接寻址和多次寻址的寻址范围</td>
<td>一次间接寻址范围：2^16，                        多次间接寻址：2^15</td>
</tr>
<tr>
<td>立即数的范围（十进制表示）</td>
<td>立即数范围：0~63（无符号数），（有符号数）与采用的机器码有关。</td>
</tr>
<tr>
<td>相对寻址的位移量（十进制表示）</td>
<td>相对寻址的位移量是：2^6&#x3D;64</td>
</tr>
<tr>
<td>上述六种寻址方式的指令哪一种执行时间最短？哪一种最长？为什么？哪一种便于程序浮动？哪一种最适合处理数组问题？</td>
<td><em><strong>立即数寻址</strong></em>执行时间最短，因为立即数在指令中直接给出；<em><strong>间接寻址</strong></em>执行时间最长，因为一次间接寻址就要两次访问；<em><strong>基址寻址</strong></em>便于程序浮动，因为其为程序分配存储空间；<em><strong>变址寻址</strong></em>便于处理数组问题，因为内容由用户给定且执行过程中允许修改</td>
</tr>
<tr>
<td>如何修改指令格式，使指令的寻址范围可扩大到4M</td>
<td>将指令的格式改为双字节指令，指令的地址字段长为16+6&#x3D;22位，则指令的直接寻址范围扩大到2^22&#x3D;4M</td>
</tr>
<tr>
<td>为使一条转移指令能转移到主存的任一位置，可采取什么措施？简要说明</td>
<td>配置22位的基址存储器，使 EA&#x3D;（IX）+ A （IX为基址寄存器）</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>概率论</title>
    <url>/2022/03/20/probability/index/</url>
    <content><![CDATA[<p>hello</p>
]]></content>
  </entry>
  <entry>
    <title>数据采集</title>
    <url>/2022/03/19/shujucaiji/index/</url>
    <content><![CDATA[<p>[TOC]</p>
<h4 id="Requests原理-："><a href="#Requests原理-：" class="headerlink" title="Requests原理 ："></a>Requests原理 ：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.tomact服务器会根据请求url中的资源路径，创建对应的Servlet对象</span><br><span class="line">2.tomact服务器，会创建request和response对象，request对象中封装请求消息数据</span><br><span class="line">3.tomact将request和response两个对象传递给service方法，并且调用service方法</span><br><span class="line">4.程序员可以通过request对象获取请求消息数据，通过response对象设置响应消息数据</span><br><span class="line">5.服务器在给浏览器做出响应之前，会从response对象中拿程序员设置的响应消息数据</span><br></pre></td></tr></table></figure>

<h4 id="Requests使用："><a href="#Requests使用：" class="headerlink" title="Requests使用："></a>Requests使用：</h4><h5 id="1-发送http请求"><a href="#1-发送http请求" class="headerlink" title="1.发送http请求"></a>1.发送http请求</h5><p>为了使用requests，需要首先将requests库import进来：</p>
<p>import requests</p>
<pre><code>import requests
</code></pre>
<p>然后，可以使用requests来发送http请求，例如发送get请求：</p>
<p>r &#x3D; requests.get(‘<a href="http://httpbin.org/ip&#39;">http://httpbin.org/ip&#39;</a>)</p>
<pre><code>r = requests.get(&#39;http://httpbin.org/ip&#39;)
</code></pre>
<p>执行此行代码，获得一个Response对象r，从r可以获取http请求的响应结果。</p>
<p>如果要发送post请求，则</p>
<p>r &#x3D; requests.post(‘<a href="http://httpbin.org/post&#39;">http://httpbin.org/post&#39;</a>, data&#x3D;{‘name’: ‘leo’})</p>
<pre><code>r = requests.post(&#39;http://httpbin.org/post&#39;, data=&#123;&#39;name&#39;: &#39;leo&#39;&#125;)
</code></pre>
<h5 id="2-构造url"><a href="#2-构造url" class="headerlink" title="2.构造url"></a>2.构造url</h5><p>我们常常将http请求的参数以url的query string的形式进行发送，传统的做法是我们使用拼凑的方式构造这个url。例如我们需要构造以下这个url：</p>
<pre><code>http://httpbin.org/get?key1=value1&amp;key2=value2
</code></pre>
<p>使用reqeuets，你可以方便地构造这个url，而不用手工拼凑。你只需要将这些参数和值构造一个字典，然后将这个字典传给params参数即可：</p>
<p>d &#x3D; {‘key1’: ‘value1’, ‘key2’: ‘value2’}<br>r &#x3D; requests.get(‘<a href="http://httpbin.org/get&#39;">http://httpbin.org/get&#39;</a>, params&#x3D;d)<br>print r.url</p>
<pre><code>d = &#123;&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: &#39;value2&#39;&#125;
r = requests.get(&#39;http://httpbin.org/get&#39;, params=d)
print r.url
</code></pre>
<p>输出</p>
<pre><code>http://httpbin.org/get?key2=value2&amp;key1=value1
</code></pre>
<p>你可以看到，key1和key2这两个参数已被正确附加到url的query string中。</p>
<h5 id="3-HTTP响应正文"><a href="#3-HTTP响应正文" class="headerlink" title="3.HTTP响应正文"></a>3.HTTP响应正文</h5><p>一个http响应的格式通常如下：</p>
<pre><code>响应行
响应报头
响应正文
</code></pre>
<p>下面是请求 <a href="http://httpbin.org/ip">http://httpbin.org/ip</a> 的http响应结果：</p>
<pre><code>HTTP/1.1 200 OK
Server: nginx
Date: Thu, 07 Jul 2016 02:53:49 GMT
Content-Type: application/json
Content-Length: 31
Connection: keep-alive
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true
[空行]
&#123;
“origin”: “43.230.90.94”
&#125;
</code></pre>
<p>注意，响应正文与响应头部之间有一空行间隔。Requests已将http响应封装成Response对象，从Response对象可获取响应正文的内容。</p>
<h5 id="3-1-响应正文文本"><a href="#3-1-响应正文文本" class="headerlink" title="3.1 响应正文文本"></a>3.1 响应正文文本</h5><p>使用Response.text，可以获取响应的正文文本内容。</p>
<p>r &#x3D; requests.get(‘<a href="http://httpbin.org/ip&#39;">http://httpbin.org/ip&#39;</a>)<br>print r.text</p>
<pre><code>r = requests.get(&#39;http://httpbin.org/ip&#39;)
print r.text
</code></pre>
<p>输出</p>
<pre><code>&#123;
“origin”: “218.107.63.234”
&#125;
</code></pre>
<p>Requests会自动对响应正文进行解码：如果Response.encoding为空，那么requests会猜测响应的编码方式，然后进行解码。如果你可以确定响应的编码方式，也可以先对Response.encoding进行设置，然后再通过Response.text获取响应正文。</p>
<h5 id="3-2-二进制响应正文"><a href="#3-2-二进制响应正文" class="headerlink" title="3.2 二进制响应正文"></a>3.2 二进制响应正文</h5><p>使用Response.content可以获取响应正文的二进制字节内容。</p>
<p>from PIL import Image<br>from StringIO import StringIO</p>
<p>r &#x3D; requests.get(‘<a href="https://img-blog.csdn.net/20150719230252020&#39;">https://img-blog.csdn.net/20150719230252020&#39;</a>)<br>image &#x3D; Image.open(StringIO(r.content))<br>print image.size  # 输出(680, 510)<br>image.show()  # Windows平台下可以打开图像</p>
<pre><code>from PIL import Image
from StringIO import StringIO

r = requests.get(&#39;https://img-blog.csdn.net/20150719230252020&#39;)
image = Image.open(StringIO(r.content))
print image.size  # 输出(680, 510)
image.show()  # Windows平台下可以打开图像
</code></pre>
<p>上面的代码使用Response.content构造了一幅图像，然后输出其尺寸并打开该图像。</p>
<h5 id="3-3-Json响应正文"><a href="#3-3-Json响应正文" class="headerlink" title="3.3 Json响应正文"></a>3.3 Json响应正文</h5><p>如果响应正文是一json串，可以使用Response.json()方法对响应正文进行json decode操作，并返回一个字典。</p>
<p>r &#x3D; requests.get(‘<a href="http://httpbin.org/ip&#39;">http://httpbin.org/ip&#39;</a>)<br>d &#x3D; r.json()<br>print d<br>print d[‘origin’]</p>
<pre><code>r = requests.get(&#39;http://httpbin.org/ip&#39;)
d = r.json()
print d
print d[&#39;origin&#39;]
</code></pre>
<p>输出：</p>
<pre><code>&#123;u’origin’: u’43.230.90.94’&#125;
u’43.230.90.94’
</code></pre>
<p>如果响应正文不是一个json串，则会报错。</p>
<h5 id="4-响应状态"><a href="#4-响应状态" class="headerlink" title="4.响应状态"></a>4.响应状态</h5><p>Response对象status_code属性标识http请求响应的状态码：</p>
<p>r &#x3D; requests.get(‘<a href="http://httpbin.org/get&#39;">http://httpbin.org/get&#39;</a>)<br>print r.status_code</p>
<pre><code>r = requests.get(&#39;http://httpbin.org/get&#39;)
print r.status_code
</code></pre>
<p>如果状态码是40X或者50X，那么可以使用Response.raise_for_status()抛出一下异常：</p>
<p>r &#x3D; requests.get(‘<a href="http://httpbin.org/status/404&#39;">http://httpbin.org/status/404&#39;</a>)<br>print r.status_code</p>
<pre><code>r = requests.get(&#39;http://httpbin.org/status/404&#39;)
print r.status_code

404
</code></pre>
<p>响应返回404，故使用以下语句会抛出异常：</p>
<p>r.raise_for_status()</p>
<pre><code>r.raise_for_status()

Traceback (most recent call last):
raise HTTPError(http_error_msg, response=self)
requests.exceptions.HTTPError: 404 Client Error: NOT FOUND for url:
http://httpbin.org/status/404
</code></pre>
<p>如果是返回200，则raise_for_status()并不会抛出异常。</p>
<p>r &#x3D; requests.get(‘<a href="http://httpbin.org/status/200&#39;">http://httpbin.org/status/200&#39;</a>)<br>print r.status_code<br>r.raise_for_status()</p>
<pre><code>r = requests.get(&#39;http://httpbin.org/status/200&#39;)
print r.status_code
r.raise_for_status()
</code></pre>
<h5 id="5-响应的头部"><a href="#5-响应的头部" class="headerlink" title="5.响应的头部"></a>5.响应的头部</h5><p>Response对象的headers属性是一个字典，可以获得http响应结果的头部的相关信息：</p>
<p>r &#x3D; requests.get(‘<a href="http://httpbin.org/headers&#39;">http://httpbin.org/headers&#39;</a>)<br>print r.headers</p>
<pre><code>r = requests.get(&#39;http://httpbin.org/headers&#39;)
print r.headers
</code></pre>
<p>输出：</p>
<pre><code>&#123;‘Content-Length’: ‘157’, ‘Server’: ‘nginx’, ‘Connection’: ‘keep-alive’, ‘Access-Control-Allow-Credentials’: ‘true’, ‘Date’: ‘Wed, 06 Jul 2016 15:53:36 GMT’, ‘Access-Control-Allow-Origin’: ‘*’, ‘Content-Type’: ‘application/json’&#125;
</code></pre>
<h5 id="6-定制请求的头部"><a href="#6-定制请求的头部" class="headerlink" title="6.定制请求的头部"></a>6.定制请求的头部</h5><p>Requests支持定制http请求的头部。为此，我们只需要构造一个字典，然后传给requests.get()的headers参数即可。</p>
<p>url &#x3D; ‘<a href="http://httpbin.org/headers&#39;">http://httpbin.org/headers&#39;</a><br>headers &#x3D; {‘user-agent’: ‘my-app&#x2F;0.0.1’}<br>r &#x3D; requests.get(url, headers&#x3D;headers)<br>print r.text</p>
<pre><code>url = &#39;http://httpbin.org/headers&#39;
headers = &#123;&#39;user-agent&#39;: &#39;my-app/0.0.1&#39;&#125;
r = requests.get(url, headers=headers)
print r.text
</code></pre>
<p><a href="http://httpbin.org/headers">http://httpbin.org/headers</a> 这个链接可以输出请求的头部，由于我们修改了请求头的user-agent字段，所以会访问这个链接会返回：</p>
<pre><code>&#123;
“headers”: &#123;
“Accept”: “/“,
“Accept-Encoding”: “gzip, deflate”,
“Host”: “httpbin.org”,
“User-Agent”: “my-app/0.0.1”
&#125;
&#125;
</code></pre>
<h5 id="7-发送POST请求"><a href="#7-发送POST请求" class="headerlink" title="7.发送POST请求"></a>7.发送POST请求</h5><p>一个http请求包括三个部分，为别为请求行，请求报头，消息主体，类似以下这样：</p>
<pre><code>请求行
请求报头
消息主体
</code></pre>
<p>HTTP协议规定post提交的数据必须放在消息主体中，但是协议并没有规定必须使用什么编码方式。服务端通过是根据请求头中的Content-Type字段来获知请求中的消息主体是用何种方式进行编码，再对消息主体进行解析。具体的编码方式包括：</p>
<pre><code>application/x-www-form-urlencoded
最常见post提交数据的方式，以form表单形式提交数据。
application/json
以json串提交数据。
multipart/form-data
一般使用来上传文件。
</code></pre>
<h5 id="7-1-以form形式发送post请求"><a href="#7-1-以form形式发送post请求" class="headerlink" title="7.1 以form形式发送post请求"></a>7.1 以form形式发送post请求</h5><p>Reqeusts支持以form表单形式发送post请求，只需要将请求的参数构造成一个字典，然后传给requests.post()的data参数即可。</p>
<p>url &#x3D; ‘<a href="http://httpbin.org/post&#39;">http://httpbin.org/post&#39;</a><br>d &#x3D; {‘key1’: ‘value1’, ‘key2’: ‘value2’}<br>r &#x3D; requests.post(url, data&#x3D;d)<br>print r.text</p>
<pre><code>url = &#39;http://httpbin.org/post&#39;
d = &#123;&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: &#39;value2&#39;&#125;
r = requests.post(url, data=d)
print r.text
</code></pre>
<p>输出：</p>
<pre><code>&#123;
“args”: &#123;&#125;,
“data”: “”,
“files”: &#123;&#125;,
“form”: &#123;
“key1”: “value1”,
“key2”: “value2”
&#125;,
“headers”: &#123;
……
“Content-Type”: “application/x-www-form-urlencoded”,
……
&#125;,
“json”: null,
……
&#125;
</code></pre>
<p>可以看到，请求头中的Content-Type字段已设置为application&#x2F;x-www-form-urlencoded，且d &#x3D; {‘key1’: ‘value1’, ‘key2’: ‘value2’}以form表单的形式提交到服务端，服务端返回的form字段即是提交的数据。</p>
<h5 id="7-2-以json形式发送post请求"><a href="#7-2-以json形式发送post请求" class="headerlink" title="7.2 以json形式发送post请求"></a>7.2 以json形式发送post请求</h5><p>可以将一json串传给requests.post()的data参数，</p>
<p>url &#x3D; ‘<a href="http://httpbin.org/post&#39;">http://httpbin.org/post&#39;</a><br>s &#x3D; json.dumps({‘key1’: ‘value1’, ‘key2’: ‘value2’})<br>r &#x3D; requests.post(url, data&#x3D;s)<br>print r.text</p>
<pre><code>url = &#39;http://httpbin.org/post&#39;
s = json.dumps(&#123;&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: &#39;value2&#39;&#125;)
r = requests.post(url, data=s)
print r.text
</code></pre>
<p>输出：</p>
<pre><code>&#123;
“args”: &#123;&#125;,
“data”: “&#123;\”key2\”: \”value2\”, \”key1\”: \”value1\”&#125;”,
“files”: &#123;&#125;,
“form”: &#123;&#125;,
“headers”: &#123;
……
“Content-Type”: “application/json”,
……
&#125;,
“json”: &#123;
“key1”: “value1”,
“key2”: “value2”
&#125;,
……
&#125;
</code></pre>
<p>可以看到，请求头的Content-Type设置为application&#x2F;json，并将s这个json串提交到服务端中。</p>
<h5 id="7-3-以multipart形式发送post请求"><a href="#7-3-以multipart形式发送post请求" class="headerlink" title="7.3 以multipart形式发送post请求"></a>7.3 以multipart形式发送post请求</h5><p>Requests也支持以multipart形式发送post请求，只需将一文件传给requests.post()的files参数即可。</p>
<p>url &#x3D; ‘<a href="http://httpbin.org/post&#39;">http://httpbin.org/post&#39;</a><br>files &#x3D; {‘file’: open(‘report.txt’, ‘rb’)}<br>r &#x3D; requests.post(url, files&#x3D;files)<br>print r.text</p>
<pre><code>url = &#39;http://httpbin.org/post&#39;
files = &#123;&#39;file&#39;: open(&#39;report.txt&#39;, &#39;rb&#39;)&#125;
r = requests.post(url, files=files)
print r.text
</code></pre>
<p>输出：</p>
<pre><code>&#123;
“args”: &#123;&#125;,
“data”: “”,
“files”: &#123;
“file”: “Hello world!”
&#125;,
“form”: &#123;&#125;,
“headers”: &#123;……
“Content-Type”: “multipart/form-data; boundary=467e443f4c3d403c8559e2ebd009bf4a”,
……
&#125;,
“json”: null,
……
&#125;
</code></pre>
<p>文本文件report.txt的内容只有一行：Hello world!，从请求的响应结果可以看到数据已上传到服务端中。</p>
<h5 id="8-Cookie设置"><a href="#8-Cookie设置" class="headerlink" title="8.Cookie设置"></a>8.Cookie设置</h5><p>使用requests，可以轻松获取响应的cookies，和设置请求的cookies。</p>
<h5 id="8-1-获取响应的cookies"><a href="#8-1-获取响应的cookies" class="headerlink" title="8.1 获取响应的cookies"></a>8.1 获取响应的cookies</h5><p>r.cookies是响应cookies的字典，通过r.cookies可访问响应带上的cookies。</p>
<p>r &#x3D; requests.get(url)<br>print r.cookies[‘example_cookie_name’]</p>
<pre><code>r = requests.get(url)
print r.cookies[&#39;example_cookie_name&#39;]
</code></pre>
<h5 id="8-2-发送带cookies的请求"><a href="#8-2-发送带cookies的请求" class="headerlink" title="8.2 发送带cookies的请求"></a>8.2 发送带cookies的请求</h5><p>url &#x3D; ‘<a href="http://httpbin.org/cookies&#39;">http://httpbin.org/cookies&#39;</a><br>cookies &#x3D; {‘cookies_are’: ‘working’}<br>r &#x3D; requests.get(url, cookies&#x3D;cookies)<br>print r.text</p>
<pre><code>url = &#39;http://httpbin.org/cookies&#39;
cookies = &#123;&#39;cookies_are&#39;: &#39;working&#39;&#125;
r = requests.get(url, cookies=cookies)
print r.text
</code></pre>
<p>输出：</p>
<pre><code>&#123;
“cookies”: &#123;
“cookies_are”: “working”
&#125;
&#125;
</code></pre>
<h5 id="9-请求的超时设置"><a href="#9-请求的超时设置" class="headerlink" title="9.请求的超时设置"></a>9.请求的超时设置</h5><p>Requests允许对一个http请求设置超时的时间，只需要在requests.get()或者requests.post()方法的timeout参数设置一个值（单位为秒）即可。</p>
<p>url &#x3D; ‘<a href="http://httpbin.org/get&#39;">http://httpbin.org/get&#39;</a><br>r &#x3D; requests.get(url, timeout&#x3D;0.001)</p>
<pre><code>url = &#39;http://httpbin.org/get&#39;
r = requests.get(url, timeout=0.001)
</code></pre>
<p>将会抛出一个超时异常：</p>
<pre><code>raise ConnectTimeout(e, request=request)
requests.exceptions.ConnectTimeout: HTTPConnectionPool(host=’httpbin.org’, port=80): Max retries exceeded with url: /get (Caused by ConnectTimeoutError(
</code></pre>
<h5 id="10-异常"><a href="#10-异常" class="headerlink" title="10.异常"></a>10.异常</h5><p>在发送http请求时，由于各种原因，requests可能会请求失败而抛出异常。常见的异常包括：</p>
<pre><code>ConnectionError
由于网络原因，无法建立连接。
HTTPError
如果响应的状态码不为200，Response.raise_for_status()会抛出HTTPError 异常。
Timeout
超时异常。
TooManyRedirects
若请求超过了设定的最大重定向次数，则会抛出一个 TooManyRedirects 异常。
</code></pre>
<p>所有requests抛出的异常都继承自 requests.exceptions.RequestException类。</p>
<h4 id="python爬取网页图片："><a href="#python爬取网页图片：" class="headerlink" title="python爬取网页图片："></a>python爬取网页图片：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">headers=&#123;</span><br><span class="line">    &#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 		Safari/537.36 Core/1.70.3861.400 QQBrowser/10.7.4313.400&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">url=&#x27;https://siamesecats.github.io/images/cover1.jpg&#x27;</span><br><span class="line">re=requests.get(url,headers=headers)</span><br><span class="line">#查看请求状态，返回200说明正常</span><br><span class="line">print(re.status_code)</span><br><span class="line">#文件储存地址</span><br><span class="line">path=&#x27;test.png&#x27;</span><br><span class="line">with open(path, &#x27;wb&#x27;) as f:</span><br><span class="line">    #把图片数据写入本地，wb表示二进制储存</span><br><span class="line">    for chunk in re.iter_content(chunk_size=128):</span><br><span class="line">        f.write(chunk)</span><br></pre></td></tr></table></figure>

<h4 id="python爬取学校官网数据："><a href="#python爬取学校官网数据：" class="headerlink" title="python爬取学校官网数据："></a>python爬取学校官网数据：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -*- encoding:utf8 -*-</span><br><span class="line">from lxml import html</span><br><span class="line">import requests</span><br><span class="line">import csv</span><br><span class="line"></span><br><span class="line"># wt是python中以文本写 的方式打开,只能写文件,如果文件不存在则创建该文件</span><br><span class="line">fp = open(&quot;html.csv&quot;,&quot;w&quot;,encoding=&#x27;utf8&#x27;,errors=&#x27;ignore&#x27;,newline=&quot;&quot;)</span><br><span class="line">writer = csv.writer(fp)</span><br><span class="line"># 上面的代码是传教CSV文件,下面是给CSV文件写入表头信息,相当于每一列的列名</span><br><span class="line">writer.writerow((&#x27;text1&#x27;,&#x27;&#x27;,&#x27;&#x27;))</span><br><span class="line"># 创建url,range的第三个参数是步长</span><br><span class="line">urls = [&quot;https://www.hait.edu.cn/tzgg/&#123;&#125;.htm&quot;.format(i) for i in range(237,240,1)]</span><br><span class="line">print(urls)</span><br><span class="line"># 请求头,用来模拟浏览器</span><br><span class="line">headers = &#123;</span><br><span class="line">    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36&#x27;,</span><br><span class="line">    &#x27;encoding&#x27;:&#x27;utf-8&#x27;,</span><br><span class="line">    &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate, sdch&#x27;,</span><br><span class="line">    &#x27;Accept-Language&#x27;: &#x27;zh-CN,zh;q=0.8&#x27;,</span><br><span class="line">    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.221 Safari/537.36 SE 2.X MetaSr 1.0&#x27;,</span><br><span class="line">    &#x27;Accept&#x27;: &#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&#x27;,</span><br><span class="line">    &#x27;Connection&#x27;: &#x27;keep-alive&#x27;</span><br><span class="line">&#125;</span><br><span class="line">for url in urls:</span><br><span class="line">    res = requests.get(url,headers=headers)</span><br><span class="line">    res.encoding=&#x27;utf-8&#x27;</span><br><span class="line">    page_text=res.text</span><br><span class="line">    # lxml库的解析html</span><br><span class="line">    selector = html.fromstring(page_text)</span><br><span class="line">    newtext = []</span><br><span class="line">    text = selector.xpath(&#x27;//*[@class=&quot;c1020491&quot;]/text()&#x27;)</span><br><span class="line">    # urldata = selector.xpath(&#x27;//*[@class=&quot;c1020491&quot;]/@href&#x27;)</span><br><span class="line">    # data = str(selector.xpath(&#x27;//*[@class=&quot;timestyle1020491&quot;]/text()&#x27;))</span><br><span class="line">    # datas = &quot;&quot;.join(data.split())</span><br><span class="line">    # print(datas)</span><br><span class="line">    # a = [text,urldata,data]</span><br><span class="line">    for text1 in text:</span><br><span class="line">        newtext.append(text1.split(&#x27;,&#x27;))</span><br><span class="line">        print(text1)</span><br><span class="line">        writer.writerow((text1,&#x27;&#x27;,&#x27;&#x27;))</span><br><span class="line"># 关闭</span><br><span class="line">fp.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="python模拟百度搜索"><a href="#python模拟百度搜索" class="headerlink" title="python模拟百度搜索:"></a>python模拟百度搜索:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"># 设置url和header信息</span><br><span class="line">wd = input(&quot;请输入搜索的内容..&quot;)</span><br><span class="line"># url = &quot;https://www.baidu.com/s?wd=&quot;+wd</span><br><span class="line">url = f&quot;https://www.baidu.com/s?wd=&#123;wd&#125;&quot;</span><br><span class="line"># url = &quot;https://www.baidu.com/s&quot;</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">  &quot;user-agent&quot;:&quot;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54 Mobile Safari/537.36&quot;</span><br><span class="line">&#125;</span><br><span class="line">params = &#123;</span><br><span class="line">    &quot;wd&quot; : wd</span><br><span class="line">&#125;</span><br><span class="line"># 发出请求</span><br><span class="line">response = requests.get(url,headers=headers,params=params)</span><br><span class="line">print(response.text)</span><br><span class="line"># 保存相应的信息</span><br><span class="line"># 以写入的方式打开文件。先删除文件原有的内容，再重新写入内容。如果文件不存在，则创建1个新的文件</span><br><span class="line">with open(wd+&quot;.html&quot;,&quot;w&quot;,encoding=&quot;utf-8&quot;) as f:</span><br><span class="line">    f.write(response.text)</span><br></pre></td></tr></table></figure>

<h4 id="python函数封装模拟百度搜索："><a href="#python函数封装模拟百度搜索：" class="headerlink" title="python函数封装模拟百度搜索："></a>python函数封装模拟百度搜索：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"># 发出请求</span><br><span class="line">def get_html(url, headers, params):</span><br><span class="line">    response = requests.get(url, headers=headers, params=params)</span><br><span class="line">    # 返回请求值</span><br><span class="line">    return response</span><br><span class="line"># 保存相应信息</span><br><span class="line">def save_html(filename,response):</span><br><span class="line">    with open(filename + &quot;.html&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:</span><br><span class="line">        f.write(response.text)</span><br><span class="line">def main():</span><br><span class="line">    # 设置url和heard信息</span><br><span class="line">    wd = input(&quot;请输入搜索内容..&quot;)</span><br><span class="line">    url = &quot;https://www.baidu.com/s&quot;</span><br><span class="line">    params = &#123;</span><br><span class="line">        &quot;wd&quot;: wd</span><br><span class="line">    &#125;</span><br><span class="line">    headers = &#123;</span><br><span class="line">        &quot;user-agent&quot;: &quot;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54 Mobile Safari/537.36&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    # get_html传递参数</span><br><span class="line">    response = get_html(url, headers, params)</span><br><span class="line">    # save_html传递参数</span><br><span class="line">    save_html(wd, response)</span><br><span class="line">#     初始化函数</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h4 id="python爬取百度贴吧"><a href="#python爬取百度贴吧" class="headerlink" title="python爬取百度贴吧:"></a>python爬取百度贴吧:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">def get_html(url, headers, params):</span><br><span class="line">  # 2 发出请求，得到响应对象</span><br><span class="line">  return requests.get(url, headers=headers, params=params)</span><br><span class="line"># 3 保存信息</span><br><span class="line">def save_html(filename, response):</span><br><span class="line"></span><br><span class="line">  with open(filename, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:</span><br><span class="line">    f.write(response.text)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">  # 1.设置请求信息</span><br><span class="line">  url = &quot;https://tieba.baidu.com/f&quot;</span><br><span class="line"></span><br><span class="line">  headers = &#123;</span><br><span class="line">  &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  kw = input(&quot;请输入要下载的贴吧内容：&quot;)</span><br><span class="line">  pageNum = int(input(&quot;请输入查找页数：&quot;))</span><br><span class="line">  for i in range(pageNum):</span><br><span class="line">    params =&#123;</span><br><span class="line">      &quot;kw&quot;:kw,</span><br><span class="line">      &quot;ie&quot; :&quot;utf-8&quot;,</span><br><span class="line">      &quot;pn&quot;: i*50</span><br><span class="line">    &#125;</span><br><span class="line">    # 2.发出请求</span><br><span class="line">    response = get_html(url, headers, params)</span><br><span class="line">    filename = kw+str((i+1))+&quot;.html&quot;</span><br><span class="line">    # 3.保存信息</span><br><span class="line">    save_html(filename, response)</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>



<h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
  </entry>
  <entry>
    <title>python数据挖掘</title>
    <url>/2022/03/20/shujuwajue/index/</url>
    <content><![CDATA[<h2 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h2><h4 id="一元线性回归分析与预测："><a href="#一元线性回归分析与预测：" class="headerlink" title="一元线性回归分析与预测："></a>一元线性回归分析与预测：</h4><h5 id="鸢尾花数据集中petal-length和petal-width两列数据进行一元线性回归分析"><a href="#鸢尾花数据集中petal-length和petal-width两列数据进行一元线性回归分析" class="headerlink" title="鸢尾花数据集中petal_length和petal_width两列数据进行一元线性回归分析"></a>鸢尾花数据集中petal_length和petal_width两列数据进行一元线性回归分析</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第一题</span><br><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"># %matplotlib inline</span><br><span class="line"># 有了%matplotlib inline 就可以省掉plt.show()</span><br><span class="line"># 导入matplotlib绘图模块</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"># 从sklearn 中导入iris数据集</span><br><span class="line">from sklearn.datasets import load_iris</span><br><span class="line"># 从sklearn中导入线性回归模型</span><br><span class="line">from sklearn.linear_model import LinearRegression</span><br><span class="line"># 加载鸢尾花数据集</span><br><span class="line">iris = load_iris()</span><br><span class="line"># 使用Pandas- DataFrame数据表结构构造鸢尾花数据</span><br><span class="line">data = pd.DataFrame(iris.data)</span><br><span class="line"># 加载满足标题</span><br><span class="line">data.columns = [&#x27;sepal-lenght&#x27;,&#x27;sepal-width&#x27;,&#x27;petal-length&#x27;,&#x27;petal-width&#x27;]</span><br><span class="line"># 展示10条数据</span><br><span class="line">data.head(10)</span><br><span class="line"># 使用petal-length和petal-width完成一元线性回归</span><br><span class="line">x = data[&#x27;petal-length&#x27;].values</span><br><span class="line">y = data[&#x27;petal-width&#x27;].values</span><br><span class="line"># 将x，y转换为有x（y）列的一行矩阵</span><br><span class="line">x = x.reshape(len(x),1)</span><br><span class="line">y = y.reshape(len(y),1)</span><br><span class="line"># 创建线性回归模型</span><br><span class="line">clf = LinearRegression()</span><br><span class="line"># 训练数据</span><br><span class="line">clf.fit(x,y)</span><br><span class="line"># 对x进行预测</span><br><span class="line">pre = clf.predict(x)</span><br><span class="line"># 使⽤scatter()绘制散点图</span><br><span class="line">plt.scatter(x,y,s=50)</span><br><span class="line"># 绘图</span><br><span class="line">plt.plot(x,pre,&#x27;r-&#x27;,linewidth=2)</span><br><span class="line">plt.xlabel(&#x27;petal-lenght&#x27;)</span><br><span class="line">plt.ylabel(&#x27;petal-width&#x27;)</span><br><span class="line"># for idx, m in enumerate(x) 方式需要同时对 idx，m两个变量同时赋值，</span><br><span class="line"># idx 赋值为x当前元素的下标，m赋值为x当前的元素。</span><br><span class="line">for idx,m in enumerate(x):</span><br><span class="line">    plt.plot([m,m],[y[idx],pre[idx]],&#x27;g-&#x27;)</span><br><span class="line"># 显示数据散点图和回归线</span><br><span class="line">plt.show()</span><br><span class="line"># 回归方程的斜率</span><br><span class="line">print(u&#x27;系数&#x27;,clf.coef_)</span><br><span class="line"># 回归方程的截距</span><br><span class="line">print(u&#x27;截距&#x27;,clf.intercept_)</span><br><span class="line"># 花萼长度为4.0的花的花萼宽度</span><br><span class="line">print(u&#x27;花萼长度为4.0的花的花萼宽度:&#x27;,clf.predict([[4.0]]))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        </p>
<p><img src="https://siamesecats.github.io/img/wj1.png" alt="img"></p>
<p>​        </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">系数 [[0.41575542]]</span><br><span class="line">截距 [-0.36307552]</span><br><span class="line">花萼长度为4.0的花的花萼宽度: [[1.29994614]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">import pandas as pd</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from sklearn import datasets</span><br><span class="line">d = datasets.load_boston()</span><br><span class="line">data = pd.DataFrame(d.data)</span><br><span class="line">data[&#x27;price&#x27;] = d.target</span><br><span class="line">data.sample(5)</span><br><span class="line"># 进行多元线性回归建模</span><br><span class="line"># 从sklearn中导入线性回归模型</span><br><span class="line">from sklearn.linear_model import LinearRegression</span><br><span class="line"># 引入多元线性回归算法模块进行相应的训练</span><br><span class="line">simple2 = LinearRegression()</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">x_train,x_test,y_train,y_test = train_test_split(x,y,random_state=666)</span><br><span class="line">simple2.fit(x_train,y_train)</span><br><span class="line">print(&#x27;多元线性回归模型系数:\n&#x27;,simple2.coef_)</span><br><span class="line">print(&#x27;多元线性回归模型常数项:\n&#x27;,simple2.intercept_)</span><br><span class="line">y_predict = simple2.predict(x_test)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多元线性回归模型系数:</span><br><span class="line"> [[0.41565311]]</span><br><span class="line">多元线性回归模型常数项:</span><br><span class="line"> [-0.36769288]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="多元线性回归建模测试："><a href="#多元线性回归建模测试：" class="headerlink" title="多元线性回归建模测试："></a>多元线性回归建模测试：</h4><h5 id="引入boston房价数据集，建模时将数据集随机分为训练集和测试集"><a href="#引入boston房价数据集，建模时将数据集随机分为训练集和测试集" class="headerlink" title="引入boston房价数据集，建模时将数据集随机分为训练集和测试集"></a>引入boston房价数据集，建模时将数据集随机分为训练集和测试集</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from sklearn import datasets</span><br><span class="line">d = datasets.load_boston()</span><br><span class="line">data = pd.DataFrame(d.data)</span><br><span class="line">data[&#x27;price&#x27;] = d.target</span><br><span class="line">data.sample(5)</span><br><span class="line"># 进行多元回归建模</span><br><span class="line">x = d.data[d.target&lt;50]</span><br><span class="line">y = d.target[d.target&lt;50]</span><br><span class="line">from sklearn.linear_model import LinearRegression</span><br><span class="line">simple2 = LinearRegression()</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">x_train,x_test,y_train,y_test = train_test_split(x,y,random_state=666)</span><br><span class="line">simple2.fit(x_train,y_train)</span><br><span class="line">print(&#x27;多元线性回归模型系数：\n&#x27;,simple2.coef_)</span><br><span class="line">print(&#x27;多元线性回归模型常数项：\n&#x27;,simple2.intercept_)</span><br><span class="line"># 模型分析</span><br><span class="line">y_predict = simple2.predict(x_test)</span><br><span class="line">from sklearn.metrics import mean_absolute_error</span><br><span class="line">from sklearn.metrics import mean_squared_error</span><br><span class="line">from sklearn.metrics import r2_score  </span><br><span class="line">#直接调用库函数进行输出R2</span><br><span class="line">print(&#x27;预测值的均方误差：&#x27;,mean_squared_error(y_test,y_predict))</span><br><span class="line">print(r2_score(y_test,y_predict))</span><br><span class="line">print(simple2.score(x_test,y_test))</span><br><span class="line">print(&#x27;各特征间的系数矩阵：\n&#x27;,simple2.coef_)               #输出多元回归算法的各个特征的系数矩阵</span><br><span class="line">print(&#x27;影响房价的特征排序：\n&#x27;,np.argsort(simple2.coef_))  #输出多元线性回归算法各个特征的系数排序，可以知道各个特征的影响度</span><br><span class="line">print(&#x27;影响房价的特征系数排序：\n&#x27;,d.feature_names[np.argsort(simple2.coef_)])  #输出各个特征按照影响系数从小到大的顺序</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多元线性回归模型系数：</span><br><span class="line"> [-1.15625837e-01  3.13179564e-02 -4.35662825e-02 -9.73281610e-02</span><br><span class="line"> -1.09500653e+01  3.49898935e+00 -1.41780625e-02 -1.06249020e+00</span><br><span class="line">  2.46031503e-01 -1.23291876e-02 -8.79440522e-01  8.31653623e-03</span><br><span class="line"> -3.98593455e-01]</span><br><span class="line">多元线性回归模型常数项：</span><br><span class="line"> 32.59756158869959</span><br><span class="line">预测值的均方误差： 13.009029984784897</span><br><span class="line">0.8009390227581041</span><br><span class="line">0.8009390227581041</span><br><span class="line">各特征间的系数矩阵：</span><br><span class="line"> [-1.15625837e-01  3.13179564e-02 -4.35662825e-02 -9.73281610e-02</span><br><span class="line"> -1.09500653e+01  3.49898935e+00 -1.41780625e-02 -1.06249020e+00</span><br><span class="line">  2.46031503e-01 -1.23291876e-02 -8.79440522e-01  8.31653623e-03</span><br><span class="line"> -3.98593455e-01]</span><br><span class="line">影响房价的特征排序：</span><br><span class="line"> [ 4  7 10 12  0  3  2  6  9 11  1  8  5]</span><br><span class="line">影响房价的特征系数排序：</span><br><span class="line"> [&#x27;NOX&#x27; &#x27;DIS&#x27; &#x27;PTRATIO&#x27; &#x27;LSTAT&#x27; &#x27;CRIM&#x27; &#x27;CHAS&#x27; &#x27;INDUS&#x27; &#x27;AGE&#x27; &#x27;TAX&#x27; &#x27;B&#x27; &#x27;ZN&#x27;</span><br><span class="line"> &#x27;RAD&#x27; &#x27;RM&#x27;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="逻辑回归建模："><a href="#逻辑回归建模：" class="headerlink" title="逻辑回归建模："></a>逻辑回归建模：</h4><h5 id="引入鸢尾花数据集随机按8比2划分训练集和测试集，并进行归一化处理"><a href="#引入鸢尾花数据集随机按8比2划分训练集和测试集，并进行归一化处理" class="headerlink" title="引入鸢尾花数据集随机按8比2划分训练集和测试集，并进行归一化处理"></a>引入鸢尾花数据集随机按8比2划分训练集和测试集，并进行归一化处理</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.datasets import load_iris</span><br><span class="line">X = load_iris().data</span><br><span class="line">y = load_iris().target</span><br><span class="line">print(&#x27;前8条数据:\n&#x27;,X[:8])</span><br><span class="line">print(&#x27;前8条数据对应的类型:\n&#x27;,y[:8])</span><br><span class="line"># 划分训练集和测试集并进行归一化</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line"># 分割测试集的比例 test_size=0.2</span><br><span class="line">X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.2,random_state=0)</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line">sc = StandardScaler()</span><br><span class="line">X_train = sc.fit_transform(X_train)</span><br><span class="line">X_test = sc.fit_transform(X_test)</span><br><span class="line">print(X_train[:5])</span><br><span class="line"># 训练逻辑回归模型并对测试集进行预测</span><br><span class="line">from sklearn.linear_model import LogisticRegression</span><br><span class="line">classifier = LogisticRegression(random_state=0)</span><br><span class="line">classifier.fit(X_train,y_train)</span><br><span class="line">y_pred = classifier.predict(X_test)</span><br><span class="line"># 用 LogisticRegression 自带的 score() 方法获取模型在测试集上的准确性</span><br><span class="line">print(&#x27;准确率:%.3f&#x27;%classifier.score(X_test,y_test))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前8条数据:</span><br><span class="line"> [[5.1 3.5 1.4 0.2]</span><br><span class="line"> [4.9 3.  1.4 0.2]</span><br><span class="line"> [4.7 3.2 1.3 0.2]</span><br><span class="line"> [4.6 3.1 1.5 0.2]</span><br><span class="line"> [5.  3.6 1.4 0.2]</span><br><span class="line"> [5.4 3.9 1.7 0.4]</span><br><span class="line"> [4.6 3.4 1.4 0.3]</span><br><span class="line"> [5.  3.4 1.5 0.2]]</span><br><span class="line">前8条数据对应的类型:</span><br><span class="line"> [0 0 0 0 0 0 0 0]</span><br><span class="line">[[ 0.61303014  0.10850105  0.94751783  0.736072  ]</span><br><span class="line"> [-0.56776627 -0.12400121  0.38491447  0.34752959]</span><br><span class="line"> [-0.80392556  1.03851009 -1.30289562 -1.33615415]</span><br><span class="line"> [ 0.25879121 -0.12400121  0.60995581  0.736072  ]</span><br><span class="line"> [ 0.61303014 -0.58900572  1.00377816  1.25412853]]</span><br><span class="line">准确率:0.767</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="多项式回归："><a href="#多项式回归：" class="headerlink" title="多项式回归："></a>多项式回归：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"># 在-4到4范围内生成1000个统一均匀分布随机数</span><br><span class="line">x = np.random.uniform(-4,4,size=1000)</span><br><span class="line"># print(x)</span><br><span class="line"># 将 x 变成 一行一列的矩阵</span><br><span class="line">X = x.reshape(-1,1)</span><br><span class="line"># print(X)</span><br><span class="line"># y=2x+2x2+2并引入标准正态分布噪声 </span><br><span class="line">y = 2*x+2*x**2+2 + np.random.normal(0,1,size=1000)</span><br><span class="line"># print(y)</span><br><span class="line"># 数据引入噪声</span><br><span class="line">plt.scatter(x,y)</span><br><span class="line"># 绘制散点图</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"># 数据做 线性回归</span><br><span class="line">from sklearn.linear_model import LinearRegression</span><br><span class="line"># 线性回归</span><br><span class="line">lin_reg = LinearRegression()</span><br><span class="line"># 根据X,y进行fit训练模型</span><br><span class="line">lin_reg.fit(X,y)</span><br><span class="line"># 预测 X对应的标记y</span><br><span class="line">y_predict = lin_reg.predict(X)</span><br><span class="line"># 设置字体样式</span><br><span class="line">plt.rcParams[&#x27;font.family&#x27;] = [&#x27;SimHei&#x27;]</span><br><span class="line"># 运行配置参数总的轴（axes）正常显示正负号</span><br><span class="line">plt.rcParams[&#x27;axes.unicode_minus&#x27;] = False</span><br><span class="line"># 绘图</span><br><span class="line">plt.title(&#x27;线性回归&#x27;)</span><br><span class="line">plt.scatter(x,y)</span><br><span class="line">plt.plot(x,y_predict,color=&#x27;r&#x27;)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"># 数据做多项式回归</span><br><span class="line">from sklearn.preprocessing import PolynomialFeatures</span><br><span class="line"># degree指定多项式最大次数</span><br><span class="line">poly = PolynomialFeatures(degree=2)</span><br><span class="line"></span><br><span class="line"># 设置最多添加几次幂的特征项</span><br><span class="line"># 根据X,进行fit训练模型</span><br><span class="line">poly.fit(X)</span><br><span class="line"># 重新映射绘图用 X 轴采样数据</span><br><span class="line">x2 = poly.transform(X)</span><br><span class="line"># 从sklearn中导入线性回归模型</span><br><span class="line">from sklearn.linear_model import LinearRegression</span><br><span class="line"># 以下代码跟线性回归一致</span><br><span class="line">lin_reg2 = LinearRegression()</span><br><span class="line">lin_reg2.fit(x2,y)</span><br><span class="line">y_predict2 = lin_reg2.predict(x2)</span><br><span class="line">plt.scatter(x,y)</span><br><span class="line">plt.plot(np.sort(x),y_predict2[np.argsort(x)],color=&#x27;r&#x27;)</span><br><span class="line">plt.title(&#x27;多项式回归&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        </p>
<p><img src="https://siamesecats.github.io/img/wj2.png" alt="img"></p>
<p>​        </p>
<p><img src="https://siamesecats.github.io/img/wj3.png" alt="img"></p>
<p>​        </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Text(0.5, 1.0, &#x27;多项式回归&#x27;)</span><br></pre></td></tr></table></figure>

<p>​        </p>
<p><img src="https://siamesecats.github.io/img/wj4.png" alt="img"></p>
<h4 id="Apriori算法："><a href="#Apriori算法：" class="headerlink" title="Apriori算法："></a>Apriori算法：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装第三方包 apyori</span><br><span class="line">#!pip install apyori</span><br><span class="line">from apyori import apriori</span><br><span class="line">import pandas as pd</span><br><span class="line"># 导入数据集 单引号 &#x27;&#x27; /</span><br><span class="line">df = pd.read_excel(&#x27;data.xls&#x27;)</span><br><span class="line"># 显示数据</span><br><span class="line">df.head()</span><br><span class="line"># 获取项集</span><br><span class="line">transactions = df.groupby(by=&#x27;OrderID&#x27;).apply(lambda x: list(x.CategoryName))</span><br><span class="line"># 显示6行数据</span><br><span class="line">transactions.head(6)</span><br><span class="line"># 进行关联规则挖掘</span><br><span class="line"># 设置支持度</span><br><span class="line">min_supp = 0.1</span><br><span class="line"># 设置置信度</span><br><span class="line">min_conf = 0.1</span><br><span class="line"># 设置提升度</span><br><span class="line">min_lift = 0.1</span><br><span class="line"># 使用apriori算法 transactions——数据集、min_support——最小支持度，可用来筛选项集</span><br><span class="line"># min_confidence——最小可信度、min_lift——最小提升度，都是float类型</span><br><span class="line">result = list(apriori(transactions=transactions,min_support=min_supp,min_confidence=min_conf,min_lift = min_lift))</span><br><span class="line">result</span><br><span class="line"></span><br><span class="line"># 显示挖掘的关联规则</span><br><span class="line">supports = []</span><br><span class="line">confidences = []</span><br><span class="line">lifts = []</span><br><span class="line">bases = []</span><br><span class="line">adds = []</span><br><span class="line">for r in result:</span><br><span class="line">#     ordered_statistics:存在的关联规则，可迭代</span><br><span class="line">#     迭代后元素属性： items_base:关联规则中的分母项集；</span><br><span class="line">#                      confidence:上面的分母规则对应的关联规则的可信度</span><br><span class="line">    for x in r.ordered_statistics:</span><br><span class="line">        supports.append(r.support)</span><br><span class="line">        confidences.append(x.confidence)</span><br><span class="line">        lifts.append(x.lift)</span><br><span class="line">        bases.append(list(x.items_base))</span><br><span class="line">        adds.append(list(x.items_add))</span><br><span class="line">resultshow = pd.DataFrame(&#123;</span><br><span class="line">    &#x27;support&#x27;:supports,</span><br><span class="line">    &#x27;confidence&#x27;:confidences,</span><br><span class="line">    &#x27;lift&#x27;:lifts,</span><br><span class="line">    &#x27;base&#x27;:bases,</span><br><span class="line">    &#x27;add&#x27;:adds</span><br><span class="line">&#125;)</span><br><span class="line">resultshow.tail(8)</span><br><span class="line"># print(resultshow)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        运行结果：</p>
<table>
<thead>
<tr>
<th></th>
<th>support</th>
<th>confidence</th>
<th>lift</th>
<th>base</th>
<th>add</th>
</tr>
</thead>
<tbody><tr>
<td>18</td>
<td>0.113253</td>
<td>0.318644</td>
<td>0.872853</td>
<td>[Confections]</td>
<td>[Dairy Products]</td>
</tr>
<tr>
<td>19</td>
<td>0.113253</td>
<td>0.310231</td>
<td>0.872853</td>
<td>[Dairy Products]</td>
<td>[Confections]</td>
</tr>
<tr>
<td>20</td>
<td>0.102410</td>
<td>0.102410</td>
<td>1.000000</td>
<td>[]</td>
<td>[Confections, Seafood]</td>
</tr>
<tr>
<td>21</td>
<td>0.102410</td>
<td>0.288136</td>
<td>0.821830</td>
<td>[Confections]</td>
<td>[Seafood]</td>
</tr>
<tr>
<td>22</td>
<td>0.102410</td>
<td>0.292096</td>
<td>0.821830</td>
<td>[Seafood]</td>
<td>[Confections]</td>
</tr>
<tr>
<td>23</td>
<td>0.110843</td>
<td>0.110843</td>
<td>1.000000</td>
<td>[]</td>
<td>[Dairy Products, Seafood]</td>
</tr>
<tr>
<td>24</td>
<td>0.110843</td>
<td>0.303630</td>
<td>0.866025</td>
<td>[Dairy Products]</td>
<td>[Seafood]</td>
</tr>
<tr>
<td>25</td>
<td>0.110843</td>
<td>0.316151</td>
<td>0.866025</td>
<td>[Seafood]</td>
<td>[Dairy Products]</td>
</tr>
</tbody></table>
<h4 id="KNN算法实现"><a href="#KNN算法实现" class="headerlink" title="KNN算法实现:"></a>KNN算法实现:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"># Puplot 提供了一套和MATLAB类似的绘图API，使得Matplotlib的机制更像MATLAB。</span><br><span class="line"># 我们只需要调用Pyplot模块所提供的函数就可以快速绘图并设置图表的各个细节</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from matplotlib.colors import ListedColormap </span><br><span class="line">from sklearn.neighbors import KNeighborsClassifier # 导入sklearn类库及KNN模型</span><br><span class="line">from sklearn.datasets import load_iris</span><br><span class="line"># 加载鸢尾花数据集，并分割成样本特征X和样本标签Y</span><br><span class="line">iris = load_iris()</span><br><span class="line">X = iris.data[:,:2]</span><br><span class="line"># print(X)</span><br><span class="line"># print(X[:,0])</span><br><span class="line">Y = iris.target</span><br><span class="line"># 绘制背景颜色和散点颜色映射表</span><br><span class="line">cmap_light = ListedColormap([&#x27;#FFAAAA&#x27;,&#x27;#AAFFAA&#x27;,&#x27;#AAAAFF&#x27;])</span><br><span class="line">cmap_bold = ListedColormap([&#x27;#FF0000&#x27;,&#x27;#00FF00&#x27;,&#x27;#0000FF&#x27;])</span><br><span class="line">clf = KNeighborsClassifier(n_neighbors= 10,weights=&#x27;uniform&#x27;)</span><br><span class="line">clf.fit(X,Y)</span><br><span class="line"># 画出决策边界</span><br><span class="line">x_min , x_max = X[:,0].min() - 1, X[:,0].max() + 1</span><br><span class="line">y_min , y_max = X[:,1].min() - 1, X[:,1].max() + 1</span><br><span class="line">xx,yy = np.meshgrid(np.arange(x_min,x_max,0.02),np.arange(y_min,y_max,0.02))</span><br><span class="line"> </span><br><span class="line">Z = clf.predict(np.c_[xx.ravel(),yy.ravel()]).reshape(xx.shape)</span><br><span class="line"> </span><br><span class="line">plt.figure()</span><br><span class="line">plt.pcolormesh(xx,yy,Z,cmap=cmap_light)</span><br><span class="line"># 绘制预测结果图</span><br><span class="line">plt.scatter(X[:,0],X[:,1],c = Y,cmap=cmap_bold)</span><br><span class="line">plt.xlim(xx.min(),xx.max()) # xlim：当前图形X轴的范围</span><br><span class="line">plt.ylim(yy.min(),yy.max())</span><br><span class="line">plt.title(&#x27;3_Class(k=10,weights=uniform)&#x27;)</span><br><span class="line">plt.show</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  运行结果：</p>
<p><img src="https://siamesecats.github.io/img/wj5.png" alt="img"></p>
<h4 id="CART决策树算法实现："><a href="#CART决策树算法实现：" class="headerlink" title="CART决策树算法实现："></a>CART决策树算法实现：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from sklearn.datasets import load_iris</span><br><span class="line">from sklearn import tree</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">iris = load_iris()</span><br><span class="line">X_train,X_test,y_train,y_test = train_test_split(iris.data,iris.target,test_size=0.2,random_state=30,shuffle=True)</span><br><span class="line">clf = tree.DecisionTreeClassifier(criterion=&#x27;entropy&#x27;)</span><br><span class="line">clf = clf.fit(X_train,y_train)</span><br><span class="line">plt.figure(dpi=150)</span><br><span class="line">tree.plot_tree(clf,feature_names=iris.feature_names,class_names=iris.target_names)</span><br><span class="line">print(&#x27;预测数据[6,5,5,2]的类别：&#x27;,clf.predict([[6,5,5,2]]))</span><br><span class="line">print(&#x27;测试集的标签：\n&#x27;,y_test)</span><br><span class="line">y_pre = clf.predict(X_test)</span><br><span class="line">print(&#x27;预测的测试集的标签：\n&#x27;,y_pre)</span><br><span class="line">print(&#x27;模型的准确率为:&#x27;,clf.score(X_test,y_test))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">预测数据[6,5,5,2]的类别： [2]</span><br><span class="line">测试集的标签：</span><br><span class="line"> [0 0 0 2 1 1 2 2 1 2 0 2 1 1 0 1 0 0 0 1 2 0 0 0 2 2 1 2 0 1]</span><br><span class="line">预测的测试集的标签：</span><br><span class="line"> [0 0 0 2 1 1 2 2 1 2 0 2 1 1 0 1 0 0 0 1 1 0 0 0 2 2 2 2 0 1]</span><br><span class="line">模型的准确率为: 0.9333333333333333</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        </p>
<p><img src="https://siamesecats.github.io/img/wj6.png" alt="img"></p>
<h4 id="SVM支持向量机算法实现"><a href="#SVM支持向量机算法实现" class="headerlink" title="SVM支持向量机算法实现:"></a>SVM支持向量机算法实现:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">from sklearn import svm</span><br><span class="line">from sklearn import datasets</span><br><span class="line">from sklearn import metrics</span><br><span class="line">from sklearn import model_selection</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">x,y = iris.data,iris.target</span><br><span class="line">x_train,x_test,y_train,y_test = model_selection.train_test_split(x,y,test_size=0.2,random_state=1)</span><br><span class="line">classifier = svm.SVC(kernel=&#x27;linear&#x27;,gamma=0.1,</span><br><span class="line">                    decision_function_shape=&#x27;ovo&#x27;,C=0.1)</span><br><span class="line">classifier.fit(x_train,y_train.ravel())</span><br><span class="line">print(&quot;SVM-输出训练集的准确率为:&quot;,classifier.score(x_train,y_train))</span><br><span class="line">print(&quot;SVM-输出测试集的准确率为:&quot;,classifier.score(x_test,y_test))</span><br><span class="line">y_hat = classifier.predict(x_test)</span><br><span class="line">classreport = metrics.classification_report(y_test,y_hat)</span><br><span class="line">print(classreport)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SVM-输出训练集的准确率为: 0.975</span><br><span class="line">SVM-输出测试集的准确率为: 0.9666666666666667</span><br><span class="line">              precision    recall  f1-score   support</span><br><span class="line"></span><br><span class="line">           0       1.00      1.00      1.00        11</span><br><span class="line">           1       1.00      0.92      0.96        13</span><br><span class="line">           2       0.86      1.00      0.92         6</span><br><span class="line"></span><br><span class="line">    accuracy                           0.97        30</span><br><span class="line">   macro avg       0.95      0.97      0.96        30</span><br><span class="line">weighted avg       0.97      0.97      0.97        30</span><br></pre></td></tr></table></figure>

<h4 id="朴素贝叶斯算法实现："><a href="#朴素贝叶斯算法实现：" class="headerlink" title="朴素贝叶斯算法实现："></a>朴素贝叶斯算法实现：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn import datasets</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.naive_bayes import MultinomialNB, GaussianNB</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib as mpl</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line">from sklearn.pipeline import Pipeline</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris() # 加载鸢尾花数据</span><br><span class="line">iris_x = iris.data  # 获取数据</span><br><span class="line"># print(iris_x)</span><br><span class="line">iris_x = iris_x[:, :2]  # 取前两个特征值</span><br><span class="line"># print(iris_x)</span><br><span class="line">iris_y = iris.target    # 0， 1， 2</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(iris_x, iris_y, test_size=0.2, random_state=1)</span><br><span class="line"># 对数据进行分类 一部分最为训练一部分作为测试</span><br><span class="line"># clf = GaussianNB()</span><br><span class="line"># ir = clf.fit(x_train, y_train)</span><br><span class="line">clf = Pipeline([</span><br><span class="line">         (&#x27;sc&#x27;, StandardScaler()),</span><br><span class="line">         (&#x27;clf&#x27;, GaussianNB())])   </span><br><span class="line">ir = clf.fit(x_train, y_train.ravel())  # 利用训练数据进行拟合</span><br><span class="line"> </span><br><span class="line"># 画图：   </span><br><span class="line">x1_max, x1_min = max(x_test[:, 0]), min(x_test[:, 0])   # 取0列特征得最大最小值</span><br><span class="line">x2_max, x2_min = max(x_test[:, 1]), min(x_test[:, 1])   # 取1列特征得最大最小值</span><br><span class="line">t1 = np.linspace(x1_min, x1_max, 500)   # 生成500个测试点</span><br><span class="line">t2 = np.linspace(x2_min, x2_max, 500)   </span><br><span class="line">x1, x2 = np.meshgrid(t1, t2)  # 生成网格采样点</span><br><span class="line">x_test1 = np.stack((x1.flat, x2.flat), axis=1)</span><br><span class="line">y_hat = ir.predict(x_test1) # 预测</span><br><span class="line">mpl.rcParams[&#x27;font.sans-serif&#x27;] = [u&#x27;simHei&#x27;]   # 识别中文保证不乱吗</span><br><span class="line">mpl.rcParams[&#x27;axes.unicode_minus&#x27;] = False</span><br><span class="line">cm_light = mpl.colors.ListedColormap([&#x27;#77E0A0&#x27;, &#x27;#FF8080&#x27;, &#x27;#A0A0FF&#x27;]) # 测试分类的颜色</span><br><span class="line">cm_dark = mpl.colors.ListedColormap([&#x27;g&#x27;, &#x27;r&#x27;, &#x27;b&#x27;])    # 样本点的颜色</span><br><span class="line">plt.figure(facecolor=&#x27;w&#x27;)</span><br><span class="line">plt.pcolormesh(x1, x2, y_hat.reshape(x1.shape), cmap=cm_light)  # y_hat  25000个样本点的画图，</span><br><span class="line">plt.scatter(x_test[:, 0], x_test[:, 1], edgecolors=&#x27;k&#x27;, s=50, c=y_test, cmap=cm_dark)   </span><br><span class="line">plt.xlabel(u&#x27;花萼长度&#x27;, fontsize=14)</span><br><span class="line">plt.ylabel(u&#x27;花萼宽度&#x27;, fontsize=14)</span><br><span class="line">plt.title(u&#x27;GaussianNB对鸢尾花数据的分类结果&#x27;, fontsize=18)</span><br><span class="line">plt.grid(True)</span><br><span class="line">plt.xlim(x1_min, x1_max)</span><br><span class="line">plt.ylim(x2_min, x2_max)</span><br><span class="line">plt.show()</span><br><span class="line">y_hat1 = ir.predict(x_test)</span><br><span class="line">result = y_hat1 == y_test</span><br><span class="line">print(result)</span><br><span class="line">acc = np.mean(result)</span><br><span class="line">print(&#x27;准确度: %.2f%%&#x27; % (100 * acc))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        运行结果：  </p>
<p><img src="https://siamesecats.github.io/img/wj7.png" alt="img"></p>
<p>​        </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ True  True False  True  True False  True  True  True  True  True  True</span><br><span class="line">  True False  True  True  True  True  True  True  True  True False  True</span><br><span class="line">  True  True  True  True  True False]</span><br><span class="line">准确度: 83.33%</span><br></pre></td></tr></table></figure>

<h4 id="随机森林算法实现："><a href="#随机森林算法实现：" class="headerlink" title="随机森林算法实现："></a>随机森林算法实现：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.tree import DecisionTreeClassifier</span><br><span class="line">from sklearn.ensemble import RandomForestClassifier</span><br><span class="line">from sklearn.datasets import load_iris</span><br><span class="line">iris = load_iris()</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">Xtrain,Xtest,Ytrain,Ytest = train_test_split(iris.data,iris.target,test_size=0.3)</span><br><span class="line">clf = DecisionTreeClassifier(random_state=0)</span><br><span class="line">rfc = RandomForestClassifier(random_state=0)</span><br><span class="line">clf = clf.fit(Xtrain,Ytrain)</span><br><span class="line">rfc = rfc.fit(Xtrain,Ytrain)</span><br><span class="line">a = clf.score(Xtest,Ytest)</span><br><span class="line">b = rfc.score(Xtest,Ytest)</span><br><span class="line">print(&quot;训练集的准确率为: &quot;,a)</span><br><span class="line">print(&quot;测试集的准确率为: &quot;,b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">训练集的准确率为:  0.9555555555555556</span><br><span class="line">测试集的准确率为:  0.9777777777777777</span><br></pre></td></tr></table></figure>
<h4 id="Kmeans算法聚类分析："><a href="#Kmeans算法聚类分析：" class="headerlink" title="Kmeans算法聚类分析："></a>Kmeans算法聚类分析：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">from sklearn.cluster import KMeans         </span><br><span class="line">#from sklearn import datasets</span><br><span class="line">from sklearn.datasets import load_iris     #从sklearn库中导入鸢尾花数据集</span><br><span class="line">iris = load_iris()</span><br><span class="line">X = iris.data[:]  </span><br><span class="line">         # 看看几行几列：（150，4） </span><br><span class="line">estimator = KMeans(n_clusters=2)       #构造聚类器</span><br><span class="line">estimator.fit(X)                       #聚类</span><br><span class="line">label_pred = estimator.labels_         #获取聚类标签</span><br><span class="line">x0 = X[label_pred == 0]</span><br><span class="line">x1 = X[label_pred == 1]</span><br><span class="line">x2 = X[label_pred == 2]</span><br><span class="line">plt.scatter(x0[:, 0], x0[:, 1], c = &quot;red&quot;, marker=&#x27;o&#x27;, label=&#x27;label0&#x27;)</span><br><span class="line">plt.scatter(x1[:, 0], x1[:, 1], c = &quot;green&quot;, marker=&#x27;*&#x27;, label=&#x27;label1&#x27;)</span><br><span class="line">plt.scatter(x2[:, 0], x2[:, 1], c = &quot;blue&quot;, marker=&#x27;+&#x27;, label=&#x27;label2&#x27;)</span><br><span class="line">plt.xlabel(&#x27;petal length&#x27;)</span><br><span class="line">plt.ylabel(&#x27;petal width&#x27;)</span><br><span class="line">plt.legend(loc=2)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        运行结果:</p>
<p><img src="https://siamesecats.github.io/img/wj9.png" alt="img"></p>
<h4 id="层次聚类的实现："><a href="#层次聚类的实现：" class="headerlink" title="层次聚类的实现："></a>层次聚类的实现：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.datasets._samples_generator import make_blobs</span><br><span class="line">from sklearn.cluster import AgglomerativeClustering</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"># python自带的迭代器模块</span><br><span class="line">from itertools import cycle</span><br><span class="line"># 产生随机数据的中心</span><br><span class="line">centers = [[1,1],[-1,-1],[1,-1]]</span><br><span class="line"># 产生的数据个数</span><br><span class="line">n_samples = 3000</span><br><span class="line"># 产生数据</span><br><span class="line">X,lables_true = make_blobs(n_samples = n_samples,centers=centers,cluster_std = 0.6,random_state=0)</span><br><span class="line"># 设置分层聚类函数</span><br><span class="line">linkages = [&#x27;ward&#x27;,&#x27;average&#x27;,&#x27;complete&#x27;]</span><br><span class="line">n_clusters_ = 3</span><br><span class="line">ac = AgglomerativeClustering(linkage=linkages[2],n_clusters = n_clusters_)</span><br><span class="line"># 训练数据</span><br><span class="line">ac.fit(X)</span><br><span class="line"># 每个数据的分类</span><br><span class="line">lables = ac.labels_</span><br><span class="line">plt.figure(1)</span><br><span class="line">plt.clf()</span><br><span class="line">colors = cycle(&#x27;bgrcmykbgrcmybgrcmykbgrcmyk&#x27;)</span><br><span class="line">for k,col in zip(range(n_clusters_),colors):</span><br><span class="line">#     根据 lables 中的值 是否等于 k，重新组成一个 True、False的数组</span><br><span class="line">    my_members = lables==k</span><br><span class="line">    plt.plot(X[my_members,0],X[my_members,1],col + &#x27;.&#x27;)</span><br><span class="line">plt.title(&#x27;Estimated number of clusters: %d&#x27; % n_clusters_)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        运行结果：</p>
<p><img src="https://siamesecats.github.io/img/wj10.png" alt="img"></p>
]]></content>
  </entry>
</search>
